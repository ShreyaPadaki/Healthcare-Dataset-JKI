# -*- coding: utf-8 -*-
"""Streamlit-code.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19PwRA34wRFheK4B4klfZeG4SEtYCRKJD
"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import pandas as pd
# import numpy as np
# import matplotlib.pyplot as plt
# import seaborn as sns
# import re
# import joblib  # For saving/loading the model
# 
# # Function to convert age interval to midpoint
# def convert_age_interval_to_midpoint(age_interval):
#     if pd.isnull(age_interval):
#         return np.nan
#     numbers = re.findall(r'\d+', str(age_interval))
#     if len(numbers) == 2:
#         try:
#             start = int(numbers[0])
#             end = int(numbers[1])
#             return (start + end) / 2
#         except ValueError:
#             return np.nan
#     elif len(numbers) == 1:
#         try:
#             return float(numbers[0])
#         except ValueError:
#             return np.nan
#     else:
#         return np.nan
# 
# # Load the data and perform preprocessing
# @st.cache_data
# def load_and_preprocess_data(filepath):
#     df = pd.read_csv(filepath)
#     df.replace(to_replace='?', value=np.nan, inplace=True)
#     df = df.drop(df.columns[df.isnull().mean() > 0.40], axis=1)
#     df['readmitted_binary'] = (df['readmitted'] == '<30').astype(int)
# 
#     categorical_cols = ['gender', 'race', 'admission_type_id']
#     df = pd.get_dummies(df, columns=categorical_cols, drop_first=True)
# 
#     df['age_midpoint'] = df['age'].apply(convert_age_interval_to_midpoint)
# 
#     # Handle potential multi-class target if needed, but the model is binary
#     if 'readmitted' in df.columns:
#         df['readmitted_multiclass'] = df['readmitted'].map({'<30': 0, '>30': 1, 'NO': 2})
#     else:
#         df['readmitted_multiclass'] = np.nan # Or handle appropriately
# 
#     X = df.drop(['readmitted', 'readmitted_binary', 'encounter_id', 'patient_nbr', 'age', 'payer_code', 'diag_1', 'diag_2', 'diag_3', 'readmitted_multiclass'], axis=1, errors='ignore')
#     y_binary = df['readmitted_binary']
# 
#     non_numeric_cols = X.select_dtypes(exclude=np.number).columns.tolist()
#     X = pd.get_dummies(X, columns=non_numeric_cols, drop_first=True)
#     X.fillna(X.mean(), inplace=True)
# 
#     # Ensure column names are valid for XGBoost
#     X.columns = ["".join (c if c.isalnum() else "_" for c in str(x)) for x in X.columns]
# 
#     return X, y_binary, df # Return the original dataframe as well for analysis/visualizations
# 
# 
# # Train the model
# @st.cache_resource
# def train_model(X, y_binary):
#     from sklearn.model_selection import train_test_split
#     import xgboost as xgb
# 
#     X_train_binary, X_test_binary, y_train_binary, y_test_binary = train_test_split(X, y_binary, test_size=0.2, random_state=42, stratify=y_binary)
#     xgb_clf_binary = xgb.XGBClassifier(objective='binary:logistic', random_state=42)
#     xgb_clf_binary.fit(X_train_binary, y_train_binary)
# 
#     # Save the trained model and test data for later use in prediction section
#     joblib.dump(xgb_clf_binary, 'xgb_model_binary.pkl')
#     X_test_binary.to_csv('X_test_binary.csv', index=False)
#     pd.DataFrame(y_test_binary).to_csv('y_test_binary.csv', index=False)
# 
#     return xgb_clf_binary, X_test_binary, y_test_binary
# 
# 
# # Load the trained model and test data
# @st.cache_resource
# def load_model_and_test_data():
#     model = joblib.load('xgb_model_binary.pkl')
#     X_test = pd.read_csv('X_test_binary.csv')
#     y_test = pd.read_csv('y_test_binary.csv')['readmitted_binary']
#     return model, X_test, y_test
# 
# # Function to predict risk for a new patient (using the trained model structure)
# def predict_risk(model, preprocessed_patient_data, feature_columns):
#     # Ensure the input data has the same columns and order as the training data
#     input_df = pd.DataFrame([preprocessed_patient_data])
#     input_df = input_df.reindex(columns=feature_columns, fill_value=0)
#     proba = model.predict_proba(input_df)[:, 1]
#     return proba[0]
# 
# 
# # Streamlit App
# st.title("Diabetic Patient Readmission Risk Predictor")
# 
# # Load and preprocess data
# filepath = '/content/diabetic_data.csv'
# if not st.session_state.get('data_loaded'):
#     with st.spinner("Loading and preprocessing data..."):
#         X, y_binary, df = load_and_preprocess_data(filepath)
#         st.session_state['X'] = X
#         st.session_state['y_binary'] = y_binary
#         st.session_state['df'] = df # Store original df
#         st.session_state['data_loaded'] = True
#         st.success("Data loaded and preprocessed!")
# else:
#     X = st.session_state['X']
#     y_binary = st.session_state['y_binary']
#     df = st.session_state['df']
# 
# 
# # Train model
# if not st.session_state.get('model_trained'):
#     with st.spinner("Training the model..."):
#         xgb_clf_binary, X_test_binary, y_test_binary = train_model(X, y_binary)
#         st.session_state['model'] = xgb_clf_binary
#         st.session_state['X_test'] = X_test_binary
#         st.session_state['y_test'] = y_test_binary
#         st.session_state['model_trained'] = True
#         st.success("Model trained!")
# else:
#     xgb_clf_binary = st.session_state['model']
#     X_test_binary = st.session_state['X_test']
#     y_test_binary = st.session_state['y_test']
# 
# 
# # --- Dashboard Sections ---
# 
# st.sidebar.header("Navigation")
# section = st.sidebar.radio("Go to", ["Overview", "Data Analysis", "Model Evaluation", "Patient Risk Prediction", "Recommendations"])
# 
# if section == "Overview":
#     st.header("Project Overview")
#     st.write("This dashboard helps hospitals identify high-risk diabetic patients likely to be readmitted within 30 days using a predictive model. Early identification enables targeted interventions to reduce readmission rates and healthcare costs.")
#     st.write("The project involves data cleaning, preprocessing, exploratory data analysis, model training (XGBoost classifier), and evaluation.")
#     st.subheader("Goal:")
#     st.write("*To build a predictive model that helps hospitals identify high-risk diabetic patients who are likely to be readmitted within 30 days thereby enabling early interventions and reducing healthcare costs.*")
# 
# elif section == "Data Analysis":
#     st.header("Exploratory Data Analysis")
# 
#     if st.checkbox("Show Raw Data"):
#         st.subheader("Raw Data Snippet")
#         st.write(df.head())
# 
#     st.subheader("Correlation Analysis")
#     st.write(f"Correlation between age and readmitted: {df['age_midpoint'].corr(df['readmitted_binary']):.2f}")
#     st.write(f"Correlation between medication count and readmitted: {df['num_medications'].corr(df['readmitted_binary']):.2f}")
# 
#     st.subheader("Diagnosis Analysis")
#     diag1_counts = df.groupby(['diag_1', 'readmitted_binary']).size().unstack(fill_value=0)
#     diag1_counts['Total'] = diag1_counts[0] + diag1_counts[1]
#     diag1_counts['Readmission_Rate'] = diag1_counts[1] / diag1_counts['Total']
#     diag1_counts_sorted = diag1_counts.sort_values(by='Readmission_Rate', ascending=False)
# 
#     st.write('Top 10 Diagnoses by Readmission Rate (diag_1):')
#     st.dataframe(diag1_counts_sorted.head(10))
# 
#     st.subheader("Correlation Matrix")
#     fig, ax = plt.subplots(figsize=(12, 8))
#     sns.heatmap(df.corr(numeric_only=True), annot=False, cmap='coolwarm', ax=ax)
#     st.pyplot(fig)
# 
#     st.subheader("Histograms of Key Numerical Features")
#     numerical_features = ['age_midpoint', 'time_in_hospital', 'num_lab_procedures', 'num_procedures', 'num_medications', 'number_outpatient', 'number_emergency', 'number_inpatient', 'number_diagnoses']
#     fig = df[numerical_features].hist(figsize=(15, 10), bins=30)
#     plt.suptitle('Histograms of Key Numerical Features', y=1.02)
#     plt.tight_layout()
#     st.pyplot(fig[0][0].get_figure()) # Display the figure containing all subplots
# 
# 
# elif section == "Model Evaluation":
#     st.header("Model Evaluation - Binary Classification")
# 
#     if st.button("Evaluate Model"):
#         with st.spinner("Evaluating the model..."):
#             from sklearn.metrics import accuracy_score, classification_report, confusion_matrix, roc_auc_score, roc_curve, auc
# 
#             y_pred_binary = xgb_clf_binary.predict(X_test_binary)
# 
#             st.subheader("Evaluation Metrics")
#             st.write(f"Accuracy: {accuracy_score(y_test_binary, y_pred_binary):.4f}")
# 
#             st.subheader("Classification Report")
#             report = classification_report(y_test_binary, y_pred_binary, target_names=['Not Readmitted (<30)', 'Readmitted <30'], output_dict=True)
#             st.dataframe(pd.DataFrame(report).transpose())
# 
#             st.subheader("Confusion Matrix")
#             cm = confusion_matrix(y_test_binary, y_pred_binary)
#             fig, ax = plt.subplots(figsize=(6, 6))
#             sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=['Not Readmitted', 'Readmitted'], yticklabels=['Not Readmitted', 'Readmitted'], ax=ax)
#             plt.xlabel('Predicted')
#             plt.ylabel('Actual')
#             st.pyplot(fig)
# 
#             st.subheader("ROC Curve")
#             y_pred_proba_binary = xgb_clf_binary.predict_proba(X_test_binary)[:, 1]
#             roc_auc_binary = roc_auc_score(y_test_binary, y_pred_proba_binary)
#             st.write(f"ROC AUC Score: {roc_auc_binary:.4f}")
# 
#             fpr, tpr, thresholds = roc_curve(y_test_binary, y_pred_proba_binary)
#             roc_auc = auc(fpr, tpr)
#             fig, ax = plt.subplots(figsize=(8, 6))
#             ax.plot(fpr, tpr, color='darkorange', lw=2, label='ROC curve (area = %0.2f)' % roc_auc)
#             ax.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
#             ax.set_xlim([0.0, 1.0])
#             ax.set_ylim([0.0, 1.05])
#             ax.set_xlabel('False Positive Rate')
#             ax.set_ylabel('True Positive Rate')
#             ax.set_title('Receiver Operating Characteristic (ROC) Curve')
#             ax.legend(loc="lower right")
#             st.pyplot(fig)
# 
# 
# elif section == "Patient Risk Prediction":
#     st.header("Predict Readmission Risk for a Patient")
# 
#     st.write("Enter patient details below to predict their 30-day readmission risk.")
# 
#     # Get the list of columns the model expects
#     feature_columns = st.session_state['X'].columns.tolist()
#     # Create input fields for some key features (simplify for demo)
#     st.subheader("Patient Features (Simplified Input)")
#     time_in_hospital = st.number_input("Time in Hospital (days)", min_value=1, max_value=14, value=5)
#     num_lab_procedures = st.number_input("Number of Lab Procedures", min_value=0, value=30)
#     num_medications = st.number_input("Number of Medications", min_value=1, value=10)
#     number_diagnoses = st.number_input("Number of Diagnoses", min_value=1, value=5)
#     age_group = st.selectbox("Age Group", ['[0-10)', '[10-20)', '[20-30)', '[30-40)', '[40-50)', '[50-60)', '[60-70)', '[70-80)', '[80-90)', '[90-100)'])
#     gender = st.selectbox("Gender", ['Female', 'Male'])
#     race = st.selectbox("Race", ['Caucasian', 'AfricanAmerican', 'Hispanic', 'Asian', 'Other'])
#     admission_type = st.selectbox("Admission Type", ['Emergency', 'Urgent', 'Elective', 'Newborn', 'Not Available', 'Null', 'Not Mapped', 'Trauma Center'])
# 
# 
#     if st.button("Predict Risk"):
#         # Create a dictionary with the input features, mimicking the processed data structure
#         # Initialize with zeros for all expected columns
#         patient_data = {col: 0 for col in feature_columns}
# 
#         # Populate with user inputs
#         patient_data['time_in_hospital'] = time_in_hospital
#         patient_data['num_lab_procedures'] = num_lab_procedures
#         patient_data['num_medications'] = num_medications
#         patient_data['number_diagnoses'] = number_diagnoses
#         patient_data['age_midpoint'] = convert_age_interval_to_midpoint(age_group) # Convert age group to midpoint
# 
#         # Handle one-hot encoded categorical features
#         if gender == 'Male':
#             patient_data['gender_Male'] = 1
#         # Handle gender_Unknown/Invalid if it exists in trained features
#         if 'gender_Unknown/Invalid' in feature_columns and gender not in ['Female', 'Male']:
#              patient_data['gender_Unknown/Invalid'] = 1
# 
#         if race != 'Caucasian': # Caucasian is the dropped first category
#             race_col_name = f'race_{race}'
#             if race_col_name in feature_columns:
#                  patient_data[race_col_name] = 1
# 
#         if admission_type != 'Emergency': # Emergency might be the dropped first category, check trained columns
#              # Need to map the user-friendly names to the actual column names used after get_dummies
#              admission_type_mapping = {
#                  'Urgent': 'admission_type_id_2',
#                  'Elective': 'admission_type_id_3',
#                  'Newborn': 'admission_type_id_4',
#                  'Not Available': 'admission_type_id_5',
#                  'Null': 'admission_type_id_6',
#                  'Not Mapped': 'admission_type_id_7',
#                  'Trauma Center': 'admission_type_id_8'
#              }
#              admission_col_name = admission_type_mapping.get(admission_type)
#              if admission_col_name and admission_col_name in feature_columns:
#                   patient_data[admission_col_name] = 1
# 
# 
#         # Ensure other numerical features are also included with default values if not specified
#         # For simplicity, we'll assume 0 for many not explicitly asked, this might need refinement
#         # based on which features are important from the model
#         # Example: if 'num_procedures' is important, add an input for it.
# 
#         with st.spinner("Predicting..."):
#             # Use the loaded model and the feature columns from training data
#             model_loaded, _, _ = load_model_and_test_data()
#             prediction_proba = predict_risk(model_loaded, patient_data, feature_columns)
#             st.subheader("Prediction Result:")
#             st.write(f"The predicted probability of readmission within 30 days is: **{prediction_proba:.2f}**")
# 
#             risk_threshold = 0.3 # Use the same threshold as in the original notebook
#             if prediction_proba >= risk_threshold:
#                 st.warning(f"This patient is identified as **High Risk** (Probability >= {risk_threshold:.2f}).")
#             else:
#                 st.info(f"This patient is identified as **Lower Risk** (Probability < {risk_threshold:.2f}).")
# 
# 
# elif section == "Recommendations":
#     st.header("Hospital Recommendations")
#     st.write("Based on the model and data analysis, here are some recommendations for the hospital:")
# 
#     st.subheader("Targeted Interventions for High-Risk Patients:")
#     st.write("1. **Flag patients with top risk scores for discharge counseling:** Identify patients with the highest predicted probabilities for targeted counseling on medication adherence, follow-up appointments, and recognizing early symptoms of deterioration.")
#     st.write("2. **Assign a follow-up nurse for high-risk diabetics:** Specifically, for patients identified as high-risk, particularly those with diabetic-related diagnoses (based on diag_1, diag_2, diag_3 analysis), assign a dedicated nurse for post-discharge follow-up calls or visits.")
#     st.write("3. **Customize post-discharge diet and medication tracking:** For at-risk patients, provide personalized diet plans and easy-to-use medication tracking tools or schedules. This is especially crucial for those with a high number of medications or complex diagnoses.")
# 
#     st.subheader("General Improvements:")
#     st.write("4. **Improve Data Quality:** Address missing values and inconsistent data entries, especially for diagnosis codes and payer code, which had a high percentage of missing values.")
#     st.write("5. **Analyze Admission Patterns:** Investigate the reasons behind high readmission rates for certain admission types (e.g., Emergency) and diagnose codes to identify potential systemic issues.")
#     st.write("6. **Review Medication Management:** Analyze why a higher number of medications correlates with readmission and explore strategies for simplifying medication regimens where possible.")
# 
# # Add a footer
# st.sidebar.markdown("---")
# st.sidebar.markdown("Created using Streamlit")